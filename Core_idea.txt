# Rationale
Pooled protocols are essential from a user experience perspective as the pioneering AMM designs have shown, and define a way to democratize access to market making in a way that order book protocols simply don't provide.
Due to the design of Cardano's UTxO model, creation of liquidity pools contained in single UTxOs managed by application logic are subject to contention, where all but one user transaction consuming the pool UTxO in a single block are bound to fail. 
Neither of the two main approaches to solving this issue are satisfactory, and the trade-offs prevent both adoption and the ability of protocol interoperability which could unlock the unique feautures Cardano could bring to DeFi.
## Order book
Representing for example swap requests and limit orders as atomic to the protocol and having traders submit their requests to an order book requires continuous manual intervention on behalf of the liquidity providers. 
The technical challenge of designing, implementing and operating bots to execute these strategies is in itself an unacceptable barrier to entry for anyone except professional and institutional traders, forcing regular investors either out of the opportunity for market making, or to rely on third party service providers to do so for them, taking the De out of DeFi.
As a direct result of this, the user experience provided by order book based Cardano DeFi protocols is subpar to the offer from other protocols elsewhere for liquidity providers.
## Batchers
Another approach is to introduce a third party organizing function, colloquially called "batchers" although sometimes referred to by different names despite serving practically the same function, such as the scoopers in Sundaeswap and the operators of the order matching engine in Axo.
Putting aside the implications of introducing this (typically permissioned or semi-permissioned) third party actor in terms of protocol security and trading integrity, there are two significant reasons why even a fully permissionless batcher system is unacceptable.
The first is the added cost to the traders, batcher fees or equivalent additions to the trading cost significantly impact not only individual trades, but the type of financial activity that can take place due to the reduced capital efficiency of swaps.
The second is that the insertion of an order batching mechanism splits the placement of orders and their execution, effectively eliminating interoperability through composing transactions, but also introducing a risk-increasing delay in time-sensitive executions such as arbitrage and liquidations.
# Problem
With the above rationale, the problem statement at hand is how can we design a pooled protocol that permits protocols satisfying user expectations such as AMMs, CLMMs and other "provide liquidity and forget" type DeFi applications, while allowing composable transactions, empowering dapp developers to make complex chains of transactions without the disruption of batchers?
# Solution
Before delving into all the various proposed details of the design, it's useful to highlight the key insight that underlie this approach. That being that rather than making complex designs to circumvent contention, due to Cardano's determinism, we can actually lean into it instead.
In particular this means that if a user has a UTxO and construct several transactions consuming this UTxO, at most one of those transactions can succeed. It is possible that all fail, but unlike an account system where two spending requests can accidentally both go through, this is not the case for regular Cardano transactions.
The same logic applies to pool UTxOs, which is the source of the contention issue in the first place.
To turn what was previously an issue into a new strength, we need to introduce a new quite simple idea, which most likely will require a new wallet standard; namely a multi-transaction.
## Multi-transaction
As a minimal example, assume a user has a UTxO U, and there are two other UTxOs A and B, and the user is happy to consume either but not both in a transaction. The user can either construct and submit transaction T_A, which takes as input U and A, or T_B which takes as input U and B.
With a multi-transaction, the user constructs and submits both T_A and T_B, knowing that at most one of them can make their way into a block, since T_A and T_B both try to consume the same input U.
At present the user would have to sign both transactions individually, however with a new wallet standard the user experience could be simplified since the outflow from the user's wallet is the same in both cases, and the inflows are all known, so the user could sign all transaction possibilities in a single action.
## Pool design
Armed with the multi-transaction concept we can go back to the design of the most fundamental action for a pooled protocol, that being consuming the pool, some user UTxO and producing an updated pool state and possibly other effects as well such as outputs going to the user or an extrnal address like a treasury. 
Although the design can apply to all pooled protocols, including lending, DEXes, possibly even synthetic assets and stablecoins, we'll use a swap as an example for simplicity.
Let's assume a user wants to swap the tokens ADA and HOSKY (not a smart user, I know), so the user holds a UTxO U containing ADA, and there is a pool UTxO P containing ADA and HOSKY, with a script defining the exchange rate of ADA and HOSKY based on the amounts contained, for example a constant product market maker.
The simplest rule would have the user provide a transaction with inputs U and P, and output an updated pool and user held UTxO followig the rules outlined in the script. This in itself is not enough, for what if there's another user that attempts to also consume P in the same block?
The initial part of the answer is to do the obvious and split the pool into appropriately many, appropriately sized pool UTxOs, P1, ... , Pn. This, however, introduces a few complicating factors by default, but there are ways of dealing with those and certain tradeoffs that are more acceptable than the introduction of batchers.
### Price indeterminism
One of the main tradeoffs is price determinism; if a user trades with pool P1 they may get a different price compared to what they would if they used pool P2. If the difference is large this leads to a very unfortunate outcome for the user in question, however there are a few relevant considerations and mitigations.
The first consideration is that users are already susceptible to price indeterminism and are used to the concept of slippage as a limiting factor to how much deviation they will allow.
A mitigation strategy is to use reference inputs as introduced with Plutus v2, and provide an exchange rate that is not just the result of the input UTxOs U and Pj, but an averaging of the price taking into consideration multiple other pools as reference inputs.
For example in a single transaction the user can consume U and P1, and provide P2, P3 and P4 as reference inputs, and get a resulting exchange rate based on the combined liquidity of all 4 pools.
This means that for n pools and (m-1) reference inputs, there are (n Choose m) possible transactions that can be constructed for a single user swap.
On its' own this is quite likely to lead to imbalanced pools, and inter-pool arbitrage will be brought up later, but this imbalance provides an attractive trading opportunity in the opposite direction, incentivizing pool rebalancing.
### Inter-pool arbitrage
In the case where a pool P1 is out of balance compared to the rest of the pools there is a rebalancing opportunity, which can be rectified by an arbitrager constructing a transaction consuming P1 and an appropriate number of other pools to rebalance them, in exchange for a small fee.
An interesting pattern can emerge due to the composability of transactions, where traders can perform a chained pool-balancing and a trade, effectively reducing or eliminating the cost of the swap, or even paying them to trade, depending on the rewarding mechanism design and parameters.
### Off-chain complexity, on-chain simplicity
The construction of the multi-transactions off-chain introduces some interesting opportunities and challenges. Although the proposed design is intended to work in a completely un-coordinated pool usage, in reality front end applications where the transactions are constructed and submitted from can coordinate their efforts to minimize actual contention in practice.
Considering that for each action there is (n Choose m) possible options to choose from, if for example a pool has been split in 32 pools and each transaction needs to include 1 consumed pool and 3 reference pools, then there are 35960 possible transaction combinations. 
Of these, the application may choose a subset based on communicated preferences with other applications, at random, based on user selection or optimized for exchange rate for example. Submitting all possible transactions is likely to simply flood the mempool of the receiving node causing all excess to drop, so subset selection is necessary.
### Multi-protocol utility, merging the fragmented liquidity
By designing pools in this way we can actually not only avoid contention, but possibly also merge the liquidity from multiple protocols, leading to a much deeper liquidity environment in Cardano DeFi which has a lot of great benefits, from price stability to reduced lending risk etc.
The interactions and incentives to collaborate in what is effectively an end-to-end change of both application logic and business model for multiple parties should best be answered by the parties involved, if it even is of any interest at all. 
Even in a project-specific deployment this design should provide unparallelled benefits to all users.
